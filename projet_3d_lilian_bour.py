# -*- coding: utf-8 -*-
"""Projet_3D_Lilian_Bour.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12RW_9PMJ3v8KNuBx3v_tpsi6XeIo0Q15
"""

import mm3d
import numpy as np
from scipy.optimize import minimize
from scipy.linalg import svd 
import cv2
import matplotlib.pyplot as plt  
import mm3d_utils

aIm1 = cv2.imread('IMG_20201126_132423.jpg', cv2.IMREAD_IGNORE_ORIENTATION)
aIm2 = cv2.imread('IMG_20201126_132431.jpg', cv2.IMREAD_IGNORE_ORIENTATION)

TPtsVec = mm3d_utils.ImportHom("points_homologues.txt")
# TPtsVec = mm3d_utils.ImportHom("7029_7030.JPG.txt")
NbPts = len(TPtsVec)
# print(np.shape(TPtsVec))
# print(TPtsVec[:,0,0])

mm3d_utils.plot_images([np.asarray(aIm1), np.asarray(aIm2)])
mm3d_utils.plot_tiepts2(np.asarray(TPtsVec, dtype=float))


# Intrinsique parameters
# Inverse distortion coefficients (k2,k4,k6)
CoeffDistInv =[0,0,0,0]
# Center of distortion
CDist=[0, 0]
# Principal point
PrincipalPoint=[2520.24315551127575,1991.97834048361847]
# Focal length
Focale=6880.20163826856879

# TODO Complete the function that calculates the radial distortion
def DistRadial(CDist, CoeffInv, P1):
    Cx = P1[0] - CDist[0]
    Cy = P1[1] - CDist[1]
    Rho2 = np.square(Cx) + np.square(Cy)

    RhoPower = Rho2
    dist = 0
    for itCoeff in CoeffInv:
        dist += itCoeff * RhoPower
        RhoPower *= Rho2

    return [P1[0] + Cx * dist, P1[1] + Cy * dist]


# TODO Complete the function that transforms a point to a bundle/direction
def DirBundle(PP, F, P):
    return [(P[0] - PP[0]) / F, (P[1] - PP[1]) / F]

# Test your implementation
PTest = [436.030000,2454.980000]
PTestDist = DistRadial(CDist,CoeffDistInv,PTest)
print("P",PTest)
print("PDist",PTestDist,"dr [",PTest[0]-PTestDist[0],",",PTest[1]-PTestDist[1],"]")

PTestDistDir = DirBundle(PrincipalPoint,Focale,PTestDist)
print("P Dir",PTestDistDir)

# Normalise image observations (image points to direction)
def Transform2DirAll(TPtsVec) :
    Res = []
    for P1,P2 in TPtsVec :
        P1 = DistRadial(PrincipalPoint,CoeffDistInv,P1)
        P1 = DirBundle(PrincipalPoint,Focale,P1)
        P2 = DistRadial(PrincipalPoint,CoeffDistInv,P2)
        P2 = DirBundle(PrincipalPoint,Focale,P2)
        Res.append([P1,P2])
    return Res


# TODO Calculate the sum of the residual errors
def CalcMatEssErr(MatE0):
    a, b, c, d, e, f, g, h = MatE0  # ith element is omitted because it is =0

    ResSom = 0
    for Pt1, Pt2 in TPtsDir:
        x1, y1 = Pt1
        x2, y2 = Pt2

        EX2 = a * x2 + b * y2 + c
        EY2 = d * x2 + e * y2 + f
        EZ2 = g * x2 + h * y2 + 1

        Res = x1 * EX2 + y1 * EY2 + EZ2
        ResSom += np.square(Res)

    return ResSom

# Normalise image points to directions
TPtsDir = Transform2DirAll(TPtsVec)

# Initialize the essential matrix with zeros
E0 = [0,0,0,0,0,0,0,0]
print("Residual error on E0 before minimization",CalcMatEssErr(E0))

E = minimize(CalcMatEssErr,E0)
print("Residual error on E0 after minimization",CalcMatEssErr(E.x),"succes ?",E.success)

# Transform the vector to a matrix
EMat = mm3d_utils.TabToMatrix(E.x)
# Print the determinant of E
print("det E0",np.linalg.det(EMat))

# Calculate the SVD decomposition
R1,Vp,R2 = svd(EMat)

# Calculate the E by enforcing the constraint
E_constr = np.matmul(R1,np.matmul(np.diag([Vp[0],Vp[1],0]),R2))

# Print the determinant of E
print("det E",np.linalg.det(E_constr))

# Print the final Essential matrix
print("E",E_constr,Vp)

#Tp 2
def Cam2WToW2Cam(R, C):
    ROut = np.linalg.inv(R)
    tOut = -np.matmul(ROut,C)
    return ROut, tOut

Z = [[0,1,0],[-1,0,0],[0,0,0]]
W = [[0,-1,0],[1,0,0],[0,0,1]]
# svd
U,D,V = svd(EMat)

#calcul de S
S = np.matmul(U,np.matmul(Z,(U.T)))

#2 solutions de translation ...
C_Cam2_v1 = U.dot([[0],[0],[1]])
C_Cam2_v2 = -U.dot([[0],[0],[1]])
# et 2 solutions de rotation
RC2W_Cam2_v1 =  np.matmul(U,np.matmul(W,V))
RC2W_Cam2_v2 =  np.matmul(U,np.matmul(np.transpose(W),V.T))

# Transformation de camera -> monde a monde -> camera
RCam2_v1,tCam2_v1 =Cam2WToW2Cam(RC2W_Cam2_v1,C_Cam2_v2)
print('\n\n\nR21 1 : ', RCam2_v1,'\nt21 1 : ', tCam2_v1)
RCam2_v2,tCam2_v2 =Cam2WToW2Cam(RC2W_Cam2_v1,C_Cam2_v2)
print('\n\nR21 2 : ', RCam2_v2,'\nt21 2 : ', tCam2_v2)
RCam2_v3,tCam2_v3 =Cam2WToW2Cam(RC2W_Cam2_v2,C_Cam2_v1)
print('\n\nR21 3 : ', RCam2_v3,'\nt21 3 : ', tCam2_v3)
RCam2_v4,tCam2_v4 =Cam2WToW2Cam(RC2W_Cam2_v2,C_Cam2_v2)
print('\n\nR21 4 : ', RCam2_v4,'\n t21 4 : ', tCam2_v4)

#Fonction de triangulation
def Triangulation(R1, t1, R2, t2, TiePoints):
    P1 = np.ones([3,4],dtype=float)
    P1[0:3,0:3] = R1
    P1[0:3,3:4] = t1
    #print('\nP1 : ',P1)
    P2 = np.ones([3,4],dtype=float)
    P2[0:3, 0:3] = R2
    P2[0:3, 3:4] = t2
    #print('P2 : ', P2)

    Result = []

    for Pt1,Pt2, in TiePoints :
        x1,y1 = Pt1
        x2,y2 = Pt2
        #Matrice A
        A = np.zeros([4,4],dtype=float)
        A[0, 0:4] = x1*P1[2,:] - P1[0,:]
        A[1, 0:4] = y1*P1[2,:] - P1[1,:]
        A[2, 0:4] = x2*P2[2,:] - P2[0,:]
        A[3, 0:4] = y2*P2[2,:] - P2[1,:]
        #print('\n\nMatrice A : ',A)

        U,D,Vt = svd(A)
        V = Vt.transpose()
        #print(V[0:3,3]/V[3,3])
        #(the 3D coordinates of the point are the last column of V, A=ADV^t, the result is a 4x1 vector [X,Y,Z,w] of homogenous coordinates, move from inhomogenous to homogenous by forcing the w=1, ie, [X/w, Y/w, Z/w ,1])
        Result.append(V[0:3,3]/V[3,3])

    return Result


# Matrice de projection pour la camera 1 :
RCam1 = np.eye(3,3, dtype=float)
tCam1 = [[0],[0],[0]]

# Triangulation des points
Structure3D_v1 = Triangulation(RCam1, tCam1, RCam2_v1, tCam2_v1,TPtsDir)
Structure3D_v2 = Triangulation(RCam1, tCam1, RCam2_v2, tCam2_v2,TPtsDir)
Structure3D_v3 = Triangulation(RCam1, tCam1, RCam2_v3, tCam2_v3,TPtsDir)
Structure3D_v4 = Triangulation(RCam1, tCam1, RCam2_v4, tCam2_v4,TPtsDir)

print(Structure3D_v1[0][:])
print(Structure3D_v2[0][:])
print(Structure3D_v3[0][:])
print(Structure3D_v4[0][:])

from google.colab import files
# Save cameras
RGB = mm3d_utils.GetIntensity(TPtsVec,aIm1,aIm2)
mm3d_utils.SaveToPly("Structure3D_v1.ply",Structure3D_v1,RGB)
files.download('Structure3D_v1.ply')
mm3d_utils.SaveToPly("Structure3D_v2.ply",Structure3D_v2,RGB)
files.download('Structure3D_v2.ply')
mm3d_utils.SaveToPly("Structure3D_v3.ply",Structure3D_v3,RGB)
files.download('Structure3D_v3.ply')
mm3d_utils.SaveToPly("Structure3D_v4.ply",Structure3D_v4,RGB)
files.download('Structure3D_v4.ply')